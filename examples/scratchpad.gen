
include(env, ref "examples/lib/prelude.gen");
include(env, ref "examples/lib/game.gen");
include(env, ref "examples/lib/list.gen");

embed define_list_type(#game_event_list, #game_event);

def game_event_buffer = struct {
  list : game_event_list,
  capacity : i64,
}

def create_game_event_buffer = fun(capacity : i64) {
  let list = game_event_list::new();
  init game_event_buffer(list, capacity)
}

def buffer_update = fun(buffer : ptr game_event_buffer, e : ptr game_event) {
  if buffer.list.length < buffer.capacity {
    game_event_list::add(buffer.list, *e);
    true
  }
  else { false }
}

def width = 800;
def height = 600;

def paddle_height = 50;
def paddle_speed = 10;
def ball_size = 10;

def window = create_game_window("SDL Example", width, height);

def vec2 = struct { x : i64, y : i64 };

def ball = struct { pos : vec2, vel : vec2 };

def paddle = struct { pos : i64, vel : i64 };

def game = struct {
  p1 : paddle,
  p2 : paddle,
  b : ball,
};

def buffered_game = struct {
  event_count : i64,
  initial_state : game,
  state : game,
};

def initial_game_state = {
  let g = {
    let ypos = (height - paddle_height) / 2;
    let b = init ball(
      init vec2((width - ball_size) / 2, (height - ball_size) / 2),
      init vec2(5, 5),
    );
    init game(
      init paddle(ypos, 0),
      init paddle(ypos, 0),
      b,
    )
  };
  init buffered_game(0, g, g);
};

def ARROW_RIGHT = 79 as u32;
def ARROW_LEFT = 80 as u32;
def ARROW_DOWN = 81 as u32;
def ARROW_UP = 82 as u32;

def game_update = fun(state : ptr game, e : ptr game_event) {
  // handle input events
  if e.tag == sdl_event_tag {
    let event_type = e.input.event_type;
    if event_type == SDL_QUIT {
      sdl_destroy_window(window);
    }
    if event_type == SDL_KEYDOWN {
      let k = to_keyboard_event(ref e.input);
      if k.keysym.scancode == ARROW_DOWN {
        state.p1.vel = paddle_speed;
      }
      if k.keysym.scancode == ARROW_UP {
        state.p1.vel = -paddle_speed;
      }
    }
    if event_type == SDL_KEYUP {
      let k = to_keyboard_event(ref e.input);
      if k.keysym.scancode == ARROW_DOWN {
        state.p1.vel = 0;
      }
      if k.keysym.scancode == ARROW_UP {
        state.p1.vel = 0;
      }
    }
  }
  // handle tick events
  if e.tag == tick_event_tag {
    state.p1.pos = state.p1.pos + state.p1.vel;
    state.p2.pos = state.p2.pos + state.p2.vel;

    let b = ref state.b;
    b.pos.x = b.pos.x + b.vel.x;
    b.pos.y = b.pos.y + b.vel.y;
    if b.pos.x > width - ball_size {
      b.pos.x = width - ball_size;
      b.vel.x = -b.vel.x;
    }
    if b.pos.x < 0 {
      b.pos.x = 0;
      b.vel.x = -b.vel.x;
    }
    if b.pos.y > height - ball_size {
      b.pos.y = height - ball_size;
      b.vel.y = -b.vel.y;
    }
    if b.pos.y < 0 {
      b.pos.y = 0;
      b.vel.y = -b.vel.y;
    }
  }
};

def render_game = fun(r : sdl_renderer_handle, state : ptr game) {
  // render
  sdl_set_draw_color(r, 0 as u8, 0 as u8, 0 as u8, 0 as u8);
  sdl_clear(r);

  sdl_set_draw_color(r, 255 as u8, 0 as u8, 0 as u8, 255 as u8);

  // paddle p1
  let rect = init sdl_rect(50 as i32, state.p1.pos as i32, 10 as i32, 50 as i32);
  sdl_fill_rect(r, ref rect);

  // paddle p2
  let rect = init sdl_rect(740 as i32, state.p2.pos as i32, 10 as i32, 50 as i32);
  sdl_fill_rect(r, ref rect);

  // ball
  let rect = init sdl_rect(state.b.pos.x as i32, state.b.pos.y as i32, ball_size as i32, ball_size as i32);
  sdl_fill_rect(r, ref rect);

  sdl_present(r);
};

def min = fun(a : i64, b : i64) { if a < b { a } else { b } }

def buffered_game_update = fun(g : ptr buffered_game, buffer : ptr game_event_buffer) {
  let len = min(buffer.list.length, buffer.capacity);
  if g.event_count > len {
    g.event_count = 0;
    g.state = g.initial_state;
  }
  for i in g.event_count to len {
    let e = game_event_list::get_ptr(buffer.list, i);
    g.event_count = g.event_count + 1;
    game_update(ref g.state, e);
  }
}

reactive input_tick = create_timer(10);

reactive sdl_input = stream(observe input_tick, poll_sdl_input);

reactive frame_tick = create_timer(1000/30);

def frame_event = init game_event(tick_event_tag, zero_init sdl_event, frame_tick);

def event = {
  if sdl_input.tick > frame_event.tick {
    sdl_input
  }
  else {
    frame_event
  }
}

reactive buffered_events = container(
  observe event,
  create_game_event_buffer(1000),
  buffer_update
);

def tweaked_buffer = init game_event_buffer(
  buffered_events.list,
  1000,
);

reactive game_state = container(
  observe tweaked_buffer,
  initial_game_state,
  buffered_game_update
);

def renderer = create_renderer(window);

render_game(renderer, ref game_state.state)
