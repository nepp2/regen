

print (typeof struct_type);



// ---------- implement template-style overloading: ----------

// def add[i64] = fun(a : i64, b : i64) {
//   a + b
// }

// def add[u64] = fun(a : u64, b : u64) {
//   a + b
// }

// print add[i64](4, 5);

// let vs = list_new[i64]();

// list_add(vs, 6);

// list_len(vs);

// --------- implement templates: ----------

// template add[A, B] = { assert(A == B); add[A] }

// template add[A] = fun(a : A, b : B) {
//   a + b
// }

// ---------- other thoughts: ----------

// template eq[A, B] = { assert(A == B); eq[A] }

// template gen_eq[T] = false;

// template eq[T] = {
//   if !gen_eq[T] {
//     error("eq not defined for type")
//   }
//   def eq_expr = {

//     let cmp_expr = ???;

//     #(fun(a : T, b : T) {
//       $cmp_expr
//     })
//   };

//   embed eq_expr
// };

// def eq[vec2] = fun(a : vec2, b : vec2) {
//   a.x == b.x && a.y == b.y
// };

