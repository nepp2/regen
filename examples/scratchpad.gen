
;; primitives

(debug 5) ;; 5
(debug (typeof 5)) ;; u64
(debug (typeof u32)) ;; type

;; pointers

(debug (ptr u64)) ;; (ptr u64)
(debug (typeof (ptr u64))) ;; type

(do
  (let p (cast (malloc 8) (ptr u64)))
  (set (* p) 500)
  (debug (* p)) ;; 500
  (let local 1000)
  (debug (* (ref local))) ;; 1000
)

;; tuples

(def pos (tuple u64 u64))
(debug (typeof pos)) ;; type

(do
  (let v (init pos 20 30))
  (debug (. v 0)) ;; 20
  (debug (. v 1)) ;; 30

  ;; field assignment
  (set (. v 1) 100)
  (debug (. v 1)) ;; 100
)

;; structs

(def pos2 (struct (x u64) (y u64)))
(debug pos2) ;; type

(do
  (let v (init pos2 40 50))
  (debug (. v x)) ;; 40
  (debug (. v y)) ;; 50

  ;; field assignment
  (set (. v y) 300)
  (debug (do 
    (. v y) ;; 300
  ))
)

;; strings

(debug (typeof "hello")) ;; (struct (ptr u8) u64)

;; arrays

(do
  (let a (array 1 2 3 4))
  (debug (typeof a)) ;; (sized_array u64 4)
  (debug (index a 0)) ;; 1
  (debug (index a 3)) ;; 4
  (let p (ref (index a 2)))
  (set (* p) 300)
  (debug (index a 2)) ;; 4
)

;; conditions

(debug (if (> 3 5) 3 5)) ;; 5

;; functions

(def add (fun ((a u64) (b u64)) u64
  (+ a b)
))

(debug (typeof add)) ;; (fn (i64 i64) i64)

(debug (add 6 7)) ;; 13

;; labelled blocks (and loops)

(do
  (let v 0)
  (label loop (do
    (if (> v 10) (do
      (break loop)
    ))
    (set v (+ v 1))
    (repeat loop)
  ))
  (debug v) ;; 11
)

;; old macros

(do
  (let n (node_from_literal 300))
  (debug (# (+ 500 ($ n))))
)

(def node_list (struct
  (data (ptr node))
  (len u64)
))

(def node_index (fun ((ns node_list) (i u64)) node (do
  (index (. ns data) i)
)))

;; (def while (macro ns (do
;;   (let condition (node_index ns 0))
;;   (let body (node_index ns 1))
;;   (# (label while_loop (do
;;     (if ($ condition) (do
;;       ($ body)
;;       break
;;     ))
;;     repeat
;;   )))
;; )))

;; (do
;;   (let i 0)
;;   (while (< i 10) (set i (i + 1)))
;;   (debug i) ;; 10
;; )

;; typed macros? const expressions?

;; can't make typed macros until type inference is separated from code generation
;; what do i actually need macros for in order to create a demo?

;; alternative path: hack macros into the compiler until patterns start to emerge
;; and a pattern becomes obvious. then design as a language feature.

;; (def + (macro ((t type) (args ((slice node)))) (
;;   (if (= t (struct u64 u64))
;;     (return (# (add_u64 ($ (index args 0)) ($ (index args 1)))))
;;   )
;;   (if (= t (struct i64 i64))
;;     (return (# (add_i64 ($ (index args 0)) ($ (index args 1)))))
;;   )
;; )))

