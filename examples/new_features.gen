
// --- New feature-set ---

// * nodes hold state, process streams and output streams.
// * input defs create a change stream sourced from code changes.
// * embed pushes the output stream from a node into a def. (this is kind of unsafe?)
// * introduced templates for ergonomics (with implicit type arguments)
// * implied the existence of embedded graphs? (for includes)

def module = fun(path : string) => Expr {
  #(open {
    let g = graph {
      signal_def contents = file_watcher($path);

      def expr = parse_graph(env, contents);

      def graph = embed expr;
    };
    g.graph
  })
};

embed module("examples/lib/prelude.gen");
embed module("examples/lib/game.gen");

def NodeDef(T, E) = struct {
  init : fn() => T,
  update : fn(t : ref T, e : ref E),
  destroy : fn(t : ref T),
};

def NodeState(T, E) = struct {
  definition : NodeDef(T, E),
  input : stream(E),
  output : stream(T),
};

// --- Timeline ---

def TimeControls = struct {
  play : bool,
  position : i64,
};

def Timeline(E) = struct {
  events : list(E),
  controls : TimeControls,
};

def TimelineEvent(E) = union { TimeControls, E };

def timeline_update(E) = fun(t : ref Timeline(E), te : ref TimelineEvent(E)) {
  if let c = te as TimeControls {
    t.controls = x;
  }
  if let e = te as E {
    if t.controls.play {
      list::add(t.events, x);
      t.controls.position = list::len(t.events);
    }
  }
};

def create_timeline_stream =
  fun(input : stream(E), controls : stream(TimeControls))
    => stream(TimelineEvent(E))
{
  // TODO: merge
};

def create_timeline(E) =
  fun(input_stream : stream(TimelineEvent(E)), controls : stream(TimeControls))
    => stream(Timeline)
{
  let t = Timeline(list(), TimeControls(false, 0));
  let timeline_input = timeline_merge(input_stream, control);
  state_stream(timeline_input, t, timeline_update)
};

// --- Live queries ---

// creates `stream(TimeControls)`, driven by code changes
input controls = TimeControls(
  // play
  true,
  // position
  0,
);

def game_window = create_window();

def game_input = {
  let wstream = get_window_input(game_view);
  let update_ticks = tick_stream(1000 / 30);
  merge_stream(wstream, update_ticks);
};

// launches a window
node timeline = create_timeline(game_input, controls);

node game_node = create_node(new_game, game_update, timeline.events);

node render_node = create_node(new_renderer, game_draw, game_node.output);
