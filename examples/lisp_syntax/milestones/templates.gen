
(def list (macro n
  ;; create type name
  (let name (sym (node_as_string n)))
  ;; if type is not defined, define type
  (if (! (env_contains env name)) (do
    (let name (symbol_as_node name))
    (eval env (#
      (def ($ name) (struct
        (data (ptr ($ t)))
        (len u64)
      ))
    ))
  ))
  ;; return type name
  (symbol_as_node name)
))

;; typed macros? const expressions?

;; can't make typed macros until type inference is separated from code generation
;; what do i actually need macros for in order to create a demo?

;; alternative path: hack macros into the compiler until patterns start to emerge
;; and a pattern becomes obvious. then design as a language feature.

;; (def + (macro ((t type) (args ((slice node)))) (
;;   (if (= t (struct u64 u64))
;;     (return (# (add_u64 ($ (index args 0)) ($ (index args 1)))))
;;   )
;;   (if (= t (struct i64 i64))
;;     (return (# (add_i64 ($ (index args 0)) ($ (index args 1)))))
;;   )
;; )))


