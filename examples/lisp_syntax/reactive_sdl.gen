
(include env (ref "examples/lib/prelude.gen"))
(include env (ref "examples/lib/sdl2.gen"))

;; ------------ Create an SDL instance --------------

(def title "SDL Example")

(def window (do
  (sdl_init SDL_INIT_VIDEO)
  (sdl_create_window
    (. title data)
    SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED
    (800 u32) (600 u32)
    SDL_WINDOW_SHOWN)
))

(def poll_input (fun ((window (ptr sdl_window_handle)) (e (ptr sdl_event)) (t (ptr void)))
  ;; TODO: polling the SDL input does not actually require the window reference,
  ;; but it should!
  (== (1 u32) (sdl_poll_event e))
))

(def input_stream
  ;; the `poll_stream` function defines a new event source
  (poll_stream
    (tick_stream 1)                       ;; the sample rate
    sdl_window_handle                     ;; event source type
    (cast (ref window) (ptr void))        ;; event source
    sdl_event                             ;; event type
    (cast poll_input poll_fn_type)        ;; the polling function
  )
)

;; ------------ Define the logic --------------

(def game (struct
  (ticker i64)
))

(def initial_game_state (init game 0))

;; one of these pointers will be null
(def game_event (struct
  (input (ptr sdl_event))
  (tick (ptr tick_event))
))

(def game_update (fun ((state (ptr game)) (e (ptr game_event))) (do
  ;; handle input events
  (let input (. e input))
  (if (!= (cast input u64) 0) (do
    (if (== (. input event_type) SDL_QUIT)
      (sdl_destroy_window window)
    )
  ))
  ;; handle tick events
  (let tick (. e tick))
  (if (!= (cast tick u64) 0) (do
    (set (. state ticker) (+ (. state ticker) 4))
    (if (> (. state ticker) 200) (set (. state ticker) 0))
  ))
)))

(def render_game (fun ((renderer (ptr sdl_renderer_handle)) (state (ptr game))) (do
  ;; render
  (let r (* renderer))
  (sdl_set_draw_color r (0 u8) (0 u8) (0 u8) (0 u8))
  (sdl_clear r)

  (sdl_set_draw_color r (255 u8) (0 u8) (0 u8) (255 u8))

  (let x (+ 50 (. state ticker)))

  (let rect (init sdl_rect (cast x u32) (50 u32) (300 u32) (200 u32)))

  (sdl_fill_rect r (ref rect))
  (sdl_present r)
)))

(def window_update (fun ((e (ptr sdl_event)) (window sdl_window_handle)) (do
  (if (== (. e event_type) SDL_QUIT)
    (sdl_destroy_window window)
  )
)))

;; ------------ Define the event graph --------------

(def update_timer (tick_stream (/ 1000 30)))

(def render_timer (tick_stream (/ 1000 60)))

(def input_to_game_event (fun ((output (ptr game_event)) (input_event (ptr sdl_event))) (do
  (let e
    (init game_event input_event (cast 0 (ptr tick_event))))
  (set (* output) e)
)))

(def tick_to_game_event (fun ((output (ptr game_event)) (tick (ptr tick_event))) (do
  (let e 
    (init game_event (cast 0 (ptr sdl_event)) tick))
  (set (* output) e)
)))

(def game_input_stream 
  (map_stream
    input_stream
    game_event
    (cast input_to_game_event map_fn_type))
)

(def game_tick_stream
  (map_stream
    update_timer
    game_event
    (cast tick_to_game_event map_fn_type))
)

;; The game must respond to both input events and game ticks
(def game_events
  (merge_stream game_input_stream game_tick_stream game_event))

;; Game state is represented as a state stream
(def game_state
  (state_stream
    game_events
    game (cast (ref initial_game_state) (ptr void))
    (cast game_update update_fn_type))
)

(def renderer
  (sdl_create_renderer window u32_max SDL_RENDERER_ACCELERATED))

;; Renderer is represented as a state stream (it's an output buffer)
(def render_stream (do
  (let game_sample (sample_stream render_timer game_state game))
  (state_stream
    game_sample
    sdl_renderer_handle (cast (ref renderer) (ptr void))
    (cast render_game update_fn_type))
))
