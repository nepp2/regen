
embed load_expr(env, ref "examples/lib/prelude.gen");
embed load_expr(env, ref "examples/lib/game.gen");
embed load_expr(env, ref "examples/lib/list.gen");
embed load_expr(env, ref "examples/scrub.gen");

embed define_list_type(#GameEventList, #GameEvent);

reactive my_file = create_watcher("examples/scratchpad.gen");
embed load_expr(env, ref my_file);

def GameEventBuffer = struct {
  list : GameEventList,
  capacity : i64,
}

def create_game_event_buffer = fun(capacity : i64) {
  let list = GameEventList::new();
  init GameEventBuffer(list, capacity)
}

def buffer_update = fun(buffer : ptr GameEventBuffer, e : ptr GameEvent) {
  if buffer.list.length < buffer.capacity {
    GameEventList::add(buffer.list, *e);
    true
  }
  else { false }
}

def width = 800;
def height = 600;

def paddle_height = 50;
def paddle_speed = 10;
def ball_size = 10;

def window = create_game_window("Pong", width, height);
def window_id = sdl_get_window_id(window);

def Vec2 = struct { x : i64, y : i64 };

def Ball = struct { pos : Vec2, vel : Vec2 };

def Paddle = struct {
  pos : Vec2,
  width : i64,
  height : i64,
  vel : i64
};

def Game = struct {
  p1 : Paddle,
  p2 : Paddle,
  b : Ball,
};

def BufferedGame = struct {
  event_count : i64,
  initial_state : Game,
  state : Game,
};

def initial_game_state = {
  let ypos = (height - paddle_height) / 2;
  let b = init Ball(
    init Vec2((width - ball_size) / 2, (height - ball_size) / 2),
    init Vec2(5, 5),
  );
  init Game(
    init Paddle(init Vec2(50, ypos), 5, paddle_height, 0),
    init Paddle(init Vec2(740, ypos), 5, paddle_height, 0),
    b,
  )
};

def new_buffered_game = fun(g : Game) {
  init BufferedGame(0, g, g);
};

def ARROW_RIGHT = 79 as u32;
def ARROW_LEFT = 80 as u32;
def ARROW_DOWN = 81 as u32;
def ARROW_UP = 82 as u32;

def game_update = fun(state : ptr Game, e : ptr GameEvent) {
  // handle input events
  if e.tag == sdl_event_tag {
    let event_type = e.input.event_type;
    if event_type == SDL_QUIT {
      sdl_destroy_window(window);
    }
    if event_type == SDL_KEYDOWN {
      let k = to_keyboard_event(ref e.input);
      if k.window_id == window_id {
        if k.keysym.scancode == ARROW_DOWN {
          state.p1.vel = paddle_speed;
        }
        if k.keysym.scancode == ARROW_UP {
          state.p1.vel = -paddle_speed;
        }
      }
    }
    if event_type == SDL_KEYUP {
      let k = to_keyboard_event(ref e.input);
      if k.window_id == window_id {
        if k.keysym.scancode == ARROW_DOWN {
          state.p1.vel = 0;
        }
        if k.keysym.scancode == ARROW_UP {
          state.p1.vel = 0;
        }
      }
    }
  }
  // handle tick events
  if e.tag == tick_event_tag {
    // move the paddles
    state.p1.pos.y = state.p1.pos.y + state.p1.vel;
    state.p2.pos.y = state.p2.pos.y + state.p2.vel;

    // move the ball
    let b = ref state.b;
    let prev_ball_pos = b.pos;
    b.pos.x = b.pos.x + b.vel.x;
    b.pos.y = b.pos.y + b.vel.y;
    // collide with walls
    if b.pos.x > width - ball_size {
      b.pos.x = width - ball_size;
      b.vel.x = -b.vel.x;
    }
    if b.pos.x < 0 {
      b.pos.x = 0;
      b.vel.x = -b.vel.x;
    }
    if b.pos.y > height - ball_size {
      b.pos.y = height - ball_size;
      b.vel.y = -b.vel.y;
    }
    if b.pos.y < 0 {
      b.pos.y = 0;
      b.vel.y = -b.vel.y;
    }

    // collide with paddle
    let p1 = ref state.p1;
    let p2 = ref state.p2;
    let p1_x = p1.pos.x + p1.width;
    if b.pos.x < p1_x {
      if prev_ball_pos.x >= p1_x {
        if b.pos.y >= p1.pos.y {
          if b.pos.y <= p1.pos.y + p1.height {
            b.pos.x = p1_x;
            b.vel.x = -b.vel.x;
          }
        }
      }
    }
    let p2_x = p2.pos.x;
    if b.pos.x > p2_x {
      if prev_ball_pos.x <= p2_x {
        if b.pos.y >= p2.pos.y {
          if b.pos.y <= p2.pos.y + p2.height {
            b.pos.x = p2_x;
            b.vel.x = -b.vel.x;
          }
        }
      }
    }
  }
};

def render_game = fun(r : SdlRendererHandle, state : ptr Game) {
  // render
  sdl_set_draw_color(r, 0 as u8, 0 as u8, 0 as u8, 0 as u8);
  sdl_clear(r);

  sdl_set_draw_color(r, 255 as u8, 0 as u8, 0 as u8, 255 as u8);

  // Paddle p1
  let rect = init sdl_rect(state.p1.pos.x as i32, state.p1.pos.y as i32, 10 as i32, state.p1.height as i32);
  sdl_fill_rect(r, ref rect);

  // Paddle p2
  let rect = init sdl_rect(state.p2.pos.x as i32, state.p2.pos.y as i32, 10 as i32, state.p2.height as i32);
  sdl_fill_rect(r, ref rect);

  // Ball
  let rect = init sdl_rect(state.b.pos.x as i32, state.b.pos.y as i32, ball_size as i32, ball_size as i32);
  sdl_fill_rect(r, ref rect);

  sdl_present(r);
};

def min = fun(a : i64, b : i64) { if a < b { a } else { b } }

def buffered_game_update = fun(g : ptr BufferedGame, buffer : ptr GameEventBuffer) {
  let len = min(buffer.list.length, buffer.capacity);
  if g.event_count > len {
    g.event_count = 0;
    g.state = g.initial_state;
  }
  for i in g.event_count to len {
    let e = GameEventList::get_ptr(buffer.list, i);
    g.event_count = g.event_count + 1;
    game_update(ref g.state, e);
  }
}

reactive input_tick = create_timer(1);

reactive sdl_input = stream(observe input_tick, poll_game_input);

reactive scrub = {
  let initial = create_scrub("Events", 400, 50);
  container(observe sdl_input, initial, scrub_update)
}

render_scrub(ref scrub);

reactive frame_tick = create_timer(1000/30);

def frame_event = init GameEvent(tick_event_tag, zero_init SdlEvent, frame_tick);

def event = {
  if sdl_input.tick > frame_event.tick {
    sdl_input
  }
  else {
    frame_event
  }
}

def buffer_size = 1050;

reactive buffered_events = container(
  observe event,
  create_game_event_buffer(buffer_size),
  buffer_update
);

def tweaked_buffer = init GameEventBuffer(
  buffered_events.list,
  (buffer_size * scrub.val) / 100,
);

reactive game_state = {
  let g = new_buffered_game(initial_game_state);
  container(observe tweaked_buffer, g, buffered_game_update)
}

def renderer = create_renderer(window);

render_game(renderer, ref game_state.state)
