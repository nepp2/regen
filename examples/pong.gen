
include(env, ref "examples/lib/prelude.gen");
include(env, ref "examples/lib/game.gen");
include(env, ref "examples/lib/list.gen");

def state_signal_builder = fun(state : expr, event : expr) {
  #{
    def update_fn = fn(state : ptr $state, event : ptr $event) => void;

    def builder = fun(
      input_signal : signal,
      initial_state : (ptr $state),
      update_function : update_fn)
    {
      register_state_signal(
        env, event_loop, input_signal,
        $state, initial_state as (ptr void),
        update_function as update_fn_type)
    };

    builder
  };
};

def game_event_list = embed new_list_type(#game_event);

def game_event_buffer = struct {
  list : game_event_list,
  capacity : i64,
}

def create_game_event_buffer = fun(capacity : i64) {
  let list = game_event_list::new();
  init game_event_buffer(list, capacity)
}

def buffer_update = fun(buffer : ptr game_event_buffer, e : ptr game_event) {
  if buffer.list.length < buffer.capacity {
    game_event_list::add(buffer.list, *e);
  }
}

def width = 800;
def height = 600;

def paddle_height = 50;
def paddle_speed = 10;
def ball_size = 10;

def window = create_game_window("SDL Example", width, height);

def vec2 = struct { x : i64, y : i64 };

def ball = struct { pos : vec2, vel : vec2 };

def paddle = struct { pos : i64, vel : i64 };

def game = struct {
  event_count : i64,
  p1 : paddle,
  p2 : paddle,
  b : ball,
};

def initial_game_state = {
  let ypos = (height - paddle_height) / 2;
  let b = init ball(
    init vec2((width - ball_size) / 2, (height - ball_size) / 2),
    init vec2(5, 5),
  );
  init game(
    0,
    init paddle(ypos, 0),
    init paddle(ypos, 0),
    b,
  )
};

def ARROW_RIGHT = 79 as u32;
def ARROW_LEFT = 80 as u32;
def ARROW_DOWN = 81 as u32;
def ARROW_UP = 82 as u32;

def game_update = fun(state : ptr game, e : ptr game_event) {
  state.event_count = state.event_count + 1;
  // handle input events
  let input = e.input;
  if input as i64 != 0 {
    if input.event_type == SDL_QUIT {
      sdl_destroy_window(window);
    }
    if input.event_type == SDL_KEYDOWN {
      let k = to_keyboard_event(input);
      if k.keysym.scancode == ARROW_DOWN {
        state.p1.vel = paddle_speed;
      }
      if k.keysym.scancode == ARROW_UP {
        state.p1.vel = -paddle_speed;
      }
    }
    if input.event_type == SDL_KEYUP {
      let k = to_keyboard_event(input);
      if k.keysym.scancode == ARROW_DOWN {
        state.p1.vel = 0;
      }
      if k.keysym.scancode == ARROW_UP {
        state.p1.vel = 0;
      }
    }
  }
  // handle tick events
  let tick = e.tick;
  if e.tick as i64 != 0 {
    state.p1.pos = state.p1.pos + state.p1.vel;
    state.p2.pos = state.p2.pos + state.p2.vel;

    let b = ref state.b;
    b.pos.x = b.pos.x + b.vel.x;
    b.pos.y = b.pos.y + b.vel.y;
    if b.pos.x > width - ball_size {
      b.pos.x = width - ball_size;
      b.vel.x = -b.vel.x;
    }
    if b.pos.x < 0 {
      b.pos.x = 0;
      b.vel.x = -b.vel.x;
    }
    if b.pos.y > height - ball_size {
      b.pos.y = height - ball_size;
      b.vel.y = -b.vel.y;
    }
    if b.pos.y < 0 {
      b.pos.y = 0;
      b.vel.y = -b.vel.y;
    }
  }
};

def render_game = fun(renderer : ptr sdl_renderer_handle, state : ptr game) {
  // render
  let r = *renderer;
  sdl_set_draw_color(r, 0 as u8, 0 as u8, 0 as u8, 0 as u8);
  sdl_clear(r);

  sdl_set_draw_color(r, 255 as u8, 0 as u8, 0 as u8, 255 as u8);

  // paddle p1
  let rect = init sdl_rect(50 as i32, state.p1.pos as i32, 10 as i32, 50 as i32);
  sdl_fill_rect(r, ref rect);

  // paddle p2
  let rect = init sdl_rect(740 as i32, state.p2.pos as i32, 10 as i32, 50 as i32);
  sdl_fill_rect(r, ref rect);

  // ball
  let rect = init sdl_rect(state.b.pos.x as i32, state.b.pos.y as i32, ball_size as i32, ball_size as i32);
  sdl_fill_rect(r, ref rect);

  sdl_present(r);
};

def min = fun(a : i64, b : i64) { if a < b { a } else { b } }

def buffered_game_update = fun(state : ptr game, buffer : ptr game_event_buffer) {
  let len = min(buffer.list.length, buffer.capacity);
  for i in state.event_count to len {
    let e = game_event_list::get_ptr(buffer.list, i);
    game_update(state, e);
  }
}

def event_signal =
  game_input_signal(sdl_input_signal(), tick_signal(1000 / 60));

def buffered_event_signal = {
  print "new event buffer";
  def builder = embed state_signal_builder(#game_event_buffer, #game_event);
  let buffer = create_game_event_buffer(1000);
  builder(event_signal, ref buffer, buffer_update)
};

def game_state_signal = {
  print "new game state";
  def builder = embed state_signal_builder(#game, #game_event_buffer);
  builder(buffered_event_signal, ref initial_game_state, buffered_game_update)
};

def renderer = create_renderer(window);

def render_signal = {
  let game_sample = sample_signal(
    tick_signal(1000 / 60) as signal,
    game_state_signal, game);
  state_signal(
    game_sample,
    sdl_renderer_handle, (ref renderer) as ptr void,
    render_game as update_fn_type);
}
