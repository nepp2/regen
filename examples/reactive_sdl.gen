
(include env (ref "examples/lib/prelude.gen"))
(include env (ref "examples/lib/sdl2.gen"))

;; ------------ Create an SDL instance --------------

(def title "SDL Example")

(def window (do
  (sdl_init SDL_INIT_VIDEO)
  (sdl_create_window
    (. title data)
    SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED
    (800 u32) (600 u32)
    SDL_WINDOW_SHOWN)
))

(def poll_input (fun ((source (ptr void)) (e (ptr sdl_event)) (t (ptr tick_event)))
  (== (1 u32) (sdl_poll_event e))
))

(def input_stream
  ;; the `source_stream` function defines a new root event source
  (source_stream
    poll_input                ;; the polling function
    (cast 0 (ptr void))       ;; the event source (unused here because sdl doesn't need one)
    (zero_init sdl_event)     ;; the initial event value (maybe it should be the type?)     
    (timer_framerate 1000))   ;; the sample timer
)

;; ------------ Define the logic --------------

(def game (struct
  (ticker i32)
))

(def new_game (fun ()
  (init game 0)
))

(def game_update (fun ((e (ptr game_event)) (state (ptr game)) (do
  ;; use the event to update the state
  (set (. game ticker) (+ (. game ticker) 1))
  (if (> (. game ticker) 100) (set (. game ticker) 0))
))))

(def render_game (fun ((state (ptr game)) (r sdl_renderer_handle)) (do
  ;; render
  (sdl_set_draw_color renderer (0 u8) (0 u8) (0 u8) (0 u8))
  (sdl_clear renderer)

  (sdl_set_draw_color renderer (255 u8) (0 u8) (0 u8) (255 u8))

  (let rect (init sdl_rect (+ 50 (. game ticker)) 50 300 200))

  (sdl_fill_rect renderer (ref rect))
  (sdl_present renderer)
)))

(def window_update (fun ((e (ptr sdl_event)) (window sdl_window_handle) (do
  (if (== (. e event_type) SDL_QUIT)
    (sdl_window_destroy window)
  )
))))

;; ------------ Define the event graph --------------

(def game_timer (timer_framerate 30))

(def game_event (struct
  (input (ptr sdl_event))
  (tick (ptr tick_event))
))

(def merge_game_event (fun ((input (ptr sdl_event)) (tick (ptr tick_event)))
  ;; one of these pointers will be null
  (init game_event input tick)
))

;; Game state is represented as a state stream
(def game_state (do
  ;; The game must respond to both input events and game ticks
  (let update_stream (merge_stream input_stream game_timer merge_game_event))
  (state_stream (new_game) game_update update_stream)
))

;; Renderer is represented as a state stream (it's an output buffer)
(def render_stream (do
  (let renderer
    (sdl_create_renderer win u32_max SDL_RENDERER_ACCELERATED))
  (let game_sample (sample_stream game_state game_timer)
  (state_stream renderer render_game game_sample)
)))

;; An SDL window has state, which includes things like
;; the size, position, title, whether the window is shown
;; or hidden, etc.
;; It can also be used to close the window.
;; This state is also represented as a state stream.
(def window_state (do
  (state_stream window window_update input_stream)
))
