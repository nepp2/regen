
include(env, ref "examples/lib/prelude.gen");
include(env, ref "examples/lib/sdl2.gen");

// ------------ Create an SDL instance --------------

def title = "SDL Example";

def window = {
  sdl_init(SDL_INIT_VIDEO);
  sdl_create_window(
    title.data, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
    800 as i32, 600 as i32, SDL_WINDOW_SHOWN)
};

def poll_input = fun(window : ptr sdl_window_handle, e : ptr sdl_event, tick : ptr void) {
  // TODO: polling the SDL input does not actually require the window reference,
  // but it should!
  sdl_poll_event(e) == (1 as i32)
};

def input_signal = {
  // the `poll_signal` function defines a new event source
  poll_signal(
    tick_signal(1),                    // the sample rate
    sdl_window_handle,                 // event source type
    (ref window) as (ptr void),        // event source
    sdl_event,                         // event type
    poll_input as poll_fn_type,        // the polling function
  )
};

// ------------ Define the logic --------------

def game = struct { ticker : i64 };

def initial_game_state = init game(0);

// one of these pointers will be null
def game_event = struct {
  input : ptr sdl_event,
  tick : ptr tick_event,
};

def game_update = fun(state : ptr game, e : ptr game_event) {
  // handle input events
  let input = e.input;
  if input as i64 != 0 {
    if input.event_type == SDL_QUIT {
      sdl_destroy_window(window);
    }
  }
  // handle tick events
  let tick = e.tick;
  if e.tick as i64 != 0 {
    state.ticker = state.ticker + 4;
    if state.ticker > 200 {
      state.ticker = 0;
    } 
  }
};

def render_game = fun(renderer : ptr sdl_renderer_handle, state : ptr game) {
  // render
  let r = *renderer;
  sdl_set_draw_color(r, 0 as u8, 0 as u8, 0 as u8, 0 as u8);
  sdl_clear(r);

  sdl_set_draw_color(r, 255 as u8, 0 as u8, 0 as u8, 255 as u8);

  let x = 50 + state.ticker;

  let rect = init sdl_rect(x as i32, 50 as i32, 300 as i32, 200 as i32);

  sdl_fill_rect(r, ref rect);
  sdl_present(r);
};

def window_update = fun(e : ptr sdl_event, window : sdl_window_handle) {
  if e.event_type == SDL_QUIT {
    sdl_destroy_window(window);
  }
};

// ------------ Define the event graph --------------

def update_timer = tick_signal(1000 / 30);

def render_timer = tick_signal(1000 / 60);

def input_to_game_event = fun(output : ptr game_event, input_event : ptr sdl_event) {
  let e =
    init game_event(input_event, 0 as ptr tick_event);
  *output = e;
};

def tick_to_game_event = fun(output : ptr game_event, tick : ptr tick_event) {
  let e  =
    init game_event(0 as ptr sdl_event, tick);
  *output = e;
};

def game_input_signal =
  map_signal(input_signal, game_event, input_to_game_event as map_fn_type);

def game_tick_signal =
  map_signal(update_timer, game_event, tick_to_game_event as map_fn_type);

// The game must respond to both input events and game ticks
def game_events =
  merge_signal(game_input_signal, game_tick_signal, game_event);

// Game state is represented as a state signal
def game_state =
  state_signal(
    game_events, game,
    (ref initial_game_state) as (ptr void),
    game_update as update_fn_type);

def renderer =
  sdl_create_renderer(window, -1 as i32, SDL_RENDERER_ACCELERATED);

// Renderer is represented as a state signal (it's an output buffer)
def render_signal = {
  let game_sample = sample_signal(render_timer, game_state, game);
  state_signal(
    game_sample,
    sdl_renderer_handle, (ref renderer) as ptr void,
    render_game as update_fn_type);
}
