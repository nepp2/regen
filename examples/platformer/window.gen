
fun create_window(title : String, width : i64, height : i64) {
  sdl_init(SDL_INIT_VIDEO);
  sdl_create_window(
    title.data, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
    width as i32, height as i32, SDL_WINDOW_SHOWN)
};

fun create_renderer(window : SdlWindowHandle) {
  let r = sdl_create_renderer(window, -1 as i32, SDL_RENDERER_ACCELERATED);
  sdl_set_blend_mode(r, 1 as u32);
  r
}

def event_type = {
  def tick = 1;
  def key_down = 2;
  def key_up = 3;
  def mouse_up = 4;
  def mouse_down = 5;
  def mouse_move = 6;
}

def keycode = {
  def arrow_right = 79 as u32;
  def arrow_left = 80 as u32;
  def arrow_down = 81 as u32;
  def arrow_up = 82 as u32;
}

type MouseEvent = struct {
  x : i64,
  y : i64,
};

type KeyEvent = struct {
  keycode : u32,
};

def EventData = {
  let size = max_u64(
    type_sizeof(MouseEvent),
    type_sizeof(KeyEvent));
  sized_array(u8, size as i64)
}

def tick_event_tag = 1;
def sdl_event_tag = 2;

// one of these pointers will be null
type Event = struct {
  tag : i64,
  tick : i64,
  data : EventData,
};

embed define_list_type(#SdlEventList, #SdlEvent);
embed define_list_type(#EventList, #Event);

fun sdl_input_to_(se : ptr SdlEvent, event : ptr Event, window_id : u32) {

}

fun sdl_input_to_event(se : ptr SdlEvent, event : ptr Event, window_id : u32) {
  let event_type = se.event_type;
  if event_type == SDL_KEYDOWN {
    let k = to_keyboard_event(se);
    if k.window_id == window_id {
      
    }
  }
  if event_type == SDL_KEYUP {
    let k = to_keyboard_event(se);
    if k.window_id == window_id {

    }
  }
  if event_type == SDL_MOUSEDOWN {
    let me = to_mouse_button_event(se);
    if me.window_id == window_id {

    }
  }
  if event_type == SDL_MOUSEUP {
    let me = to_mouse_button_event(se);
    if me.window_id == window_id {
      
    }
  }
  if event_type == SDL_MOUSEMOTION {
    let mm = to_mouse_motion_event(se);
    if mm.window_id == window_id {
      
    }
  }
  false
}

fun poll_sdl_events(es : SdlEventList, tick : i64) {
  let start_len = es.length;
  let sdl_event = zero_init SdlEvent;
  while sdl_poll_event(ref sdl_event) == (1 as i32) {
    SdlEventList::add(es, sdl_event);
  }
  let changed = es.length > start_len;
  changed
}

fun flush_and_poll_input(es : SdlEventList, tick : i64) {
  if es.length > 0 {
    SdlEventList::clear(es);
    poll_sdl_events(es, tick);
    true
  }
  else {
    poll_sdl_events(es, tick)
  }
}
