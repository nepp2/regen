
;; *{ size : u64, kind : symbol, kind_info : *void }
(def new_type (fun (size kind kind_info) (
  ;; allocate type
  (let p (malloc 24))
  (store u64 p size)
  (store u64 (+ p 8) kind)
  (store u64 (+ p 16) kind_info)
  p
)))

(def type_size_of (fun (type) (
  (load u64 type)
)))

(def type_kind (fun (type) (
  (load u64 (+ type 8))
)))

(def type_kind_info (fun (type) (
  (load u64 (+ type 16))
)))

(def max (fun (a b) (
  (if (> a b) (a) (b))
)))

(def min (fun (a b) (
  (if (< a b) (a) (b))
)))

;; dynamic array or word-sized elements (64 bit)
;; *{ element_count : u64, data : *void, capacity : u64 }
(def list64_create_empty (fun () (
  (let p (malloc 24))
  (store u64 p 0)
  (store u64 (+ p 8) 0)
  (store u64 (+ p 16) 0)
  p
)))

(def list64_push (fun (array v) (
  (let element_count (load u64 array))
  (let capacity (load u64 (+ array 16)))
  (if (= capacity element_count) (
    (let new_capacity (max (* 2 capacity) 8))
    (let old_data (load u64 (+ array 8)))
    (let new_data (malloc (* new_capacity 8)))
    (memcpy new_data old_data (* capacity 8))
    (free old_data)
    (store u64 (+ array 8) new_data)
    (store u64 (+ array 16) new_capacity)
  ))
  (let data (load u64 (+ array 8)))
  (store u64 (+ data (* element_count 8)) v)
  (store u64 array (+ element_count 1))
)))

(def list64_len (fun (array) (
  (load u64 array)
)))

(def list64_index (fun (array index) (
  (let data (load u64 (+ array 8)))
  (+ data (* 8 index))
)))

(def list64_set (fun (array index value) (
  (store u64 (list64_index array index) value)
)))

(def list64_get (fun (array index) (
  (load u64 (list64_index array index))
)))

(def node_children (fun (node) (
  (let cs (byte_chunk 16))
  (node_children_c (ref cs) node)
  cs
)))